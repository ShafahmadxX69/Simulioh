<!DOCTYPE html> 
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Container Visualizer – Fixed Stair Packing</title>
  <style>
    :root {
      --panel-bg: #f7f7f8;
      --border: #d8d8de;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
    body { margin: 0; overflow: hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    canvas { display: block; }

    #sidebar {
      position: absolute; inset: 0 auto 0 0; width: 280px; background: var(--panel-bg);
      border-right: 1px solid var(--border); z-index: 10; box-sizing: border-box; padding: 12px;
      overflow-y: auto;
    }
    #sidebar h3 { margin: 0 0 8px; }
    .containerBox { background: #fff; border: 1px solid var(--border); border-radius: 10px; padding: 10px; margin-bottom: 10px; }
    .muted { color: #666; font-size: 12px; }
    .row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    .tag { border: 1px solid var(--border); border-radius: 999px; padding: 2px 8px; font-size: 12px; background: #fff; }

    #reportContainer {
      position: absolute; left: 280px; right: 0; bottom: 0; background: rgba(255,255,255,0.96);
      border-top: 2px solid #000; z-index: 5; font-family: var(--mono); font-size: 12px;
      max-height: 35%; overflow: auto; display: flex; flex-wrap: wrap; gap: 8px; padding: 8px;
    }
    .reportBox { border: 1px solid var(--border); background: #fff; border-radius: 8px; padding: 10px; white-space: pre-wrap; flex: 1 1 280px; }

    #topbar {
      position: absolute; left: 280px; right: 0; top: 0; height: 46px; background: rgba(255,255,255,0.9);
      border-bottom: 1px solid var(--border); display: flex; align-items: center; gap: 8px; padding: 0 10px; z-index: 8;
      backdrop-filter: blur(4px);
    }
    #topbar button, #topbar select {
      border: 1px solid var(--border); background: #fff; padding: 6px 10px; border-radius: 8px; cursor: pointer; font-size: 13px;
    }
    #topbar .spacer { flex: 1; }
  </style>
</head>
<body>
  <div id="sidebar">
    <h3>Container List</h3>
    <div id="containerList"></div>
  </div>
  <div id="topbar">
    <button id="btnRenderDummy" title="Render contoh payload">Render Dummy</button>
    <button id="btnClearCache" title="Hapus cache lokal">Clear Cache</button>
    <label class="muted">Unit mm</label>
    <div class="spacer"></div>
    <span class="muted">Tip: Kirim payload via <code>postMessage</code> { type: "RENDER_CONTAINER", payload }</span>
  </div>
  <div id="reportContainer"></div>
  <canvas id="threeCanvas"></canvas>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script>
  // ------------------ CONFIG ------------------
  const containerSizeMap = {
    "20FT (GP)": { length: 5895, width: 2350, height: 2392 },
    "40FT (GP)": { length: 12029, width: 2350, height: 2392 },
    "40FT (HQ)": { length: 12029, width: 2350, height: 2697 }
  };

  // ------------------ THREE SETUP ------------------
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0xffffff);
  const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 100000);
  camera.position.set(9000, 6000, 9000);

  const renderer = new THREE.WebGLRenderer({ canvas: document.querySelector('#threeCanvas'), antialias: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);

  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.08;

  const ambient = new THREE.AmbientLight(0xffffff, 0.9);
  scene.add(ambient);
  const dir = new THREE.DirectionalLight(0xffffff, 0.6);
  dir.position.set(1,2,1);
  scene.add(dir);

  const mainGroup = new THREE.Group();
  scene.add(mainGroup);

  let boxMeshes = [], containerOffsets = [], data = [];

  // ------------------ UTIL ------------------
  function hashPayload(payload) {
    try { return btoa(unescape(encodeURIComponent(JSON.stringify(payload)))).slice(0, 160); }
    catch { return String(Date.now()); }
  }
  function clearScene() { mainGroup.clear(); boxMeshes = []; }

  function withOutline(mesh, color = 0x000000) {
    const edges = new THREE.EdgesGeometry(mesh.geometry);
    const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color }));
    mesh.add(line);
    return mesh;
  }

  function addBox(dim, pos, color, key) {
    const geometry = new THREE.BoxGeometry(dim.l, dim.h, dim.w);
    const material = new THREE.MeshStandardMaterial({ color: new THREE.Color(color), transparent: false, opacity: 0.95 });
    const box = new THREE.Mesh(geometry, material);
    box.position.set(pos[0], pos[1], pos[2]);
    box.userData.key = key;
    withOutline(box, 0x000000);
    mainGroup.add(box);
    boxMeshes.push(box);
  }

  function drawFromCache(boxDataArray, containers) {
    clearScene();
    containerOffsets = [];
    containers.forEach((c, i) => drawContainerWireframe(c.type, i));
    boxDataArray.forEach(d => addBox({ l: d.l, h: d.h, w: d.w }, d.position, d.color, d.key));
  }

  // ------------------ CORE RENDER ------------------
  function renderFromData(payload, { useCache = true } = {}) {
    const reportEl = document.getElementById('reportContainer');
    const listEl = document.getElementById('containerList');

    const hash = hashPayload(payload);
    const cacheKey = `cachedBoxes_${hash}`;

    if (useCache) {
      const cached = localStorage.getItem(cacheKey);
      if (cached) {
        const parsed = JSON.parse(cached);
        drawFromCache(parsed.boxes, parsed.containers);
        listEl.innerHTML = buildSidebar(payload);
        reportEl.innerHTML = buildReport(parsed.stats);
        return;
      }
    }

    clearScene(); reportEl.innerHTML = ''; listEl.innerHTML = '';
    data = payload; containerOffsets = [];

    const allBoxes = []; const globalStats = [];

    payload.forEach((containerObj, cIndex) => {
      const container = drawContainerWireframe(containerObj.type, cIndex);
      const failedMap = {};
      const boxList = containerObj.items.map((i, idx) => ({
        ...i,
        key: `${i.model} ${i.size}\" (C${cIndex+1}-L${idx+1})`
      }));

      const placed = stairPack(container, boxList, failedMap);
      allBoxes.push(...placed.drawn);

      globalStats.push({
        containerIndex: cIndex+1,
        type: containerObj.type,
        placed: placed.countPlaced,
        failed: placed.countFailed,
        failedMap
      });
    });

    localStorage.setItem(cacheKey, JSON.stringify({ boxes: allBoxes, containers: payload.map(p=>({type:p.type})) , stats: globalStats }));

    listEl.innerHTML = buildSidebar(payload);
    reportEl.innerHTML = buildReport(globalStats);
  }

  // ------------------ PACKING FIXED ------------------
  function stairPack(container, items, failedMap) {
    const size = container.size;

    items.sort((a, b) => {
      const va = a.dimensions.l * a.dimensions.w * a.dimensions.h;
      const vb = b.dimensions.l * b.dimensions.w * b.dimensions.h;
      if (vb !== va) return vb - va;
      return b.dimensions.h - a.dimensions.h;
    });

    let cursorX = 0;      
    let cursorZ = 0;      
    let cursorY = 0;      
    let rowDepthX = 0;    
    let layerHeightY = 0; 

    const drawn = [];
    let countPlaced = 0, countFailed = 0;

    const randomColor = () => '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6,'0');

    for (const item of items) {
      const qty = Math.max(1, Number(item.qty)||1);
      for (let q=0; q<qty; q++) {
        const rotations = getAllRotations(item.dimensions);
        let chosen = null;

        for (const rot of rotations) {
          let x = cursorX, z = cursorZ, y = cursorY;
          let rd = rowDepthX, lh = layerHeightY;

          if (z + rot.w > size.width) {
            z = 0; x = x + rd; rd = 0;
          }
          if (x + rot.l > size.length) {
            x = 0; z = 0; y = y + lh; lh = 0;
          }
          if (y + rot.h > size.height) continue;

          chosen = { rot, x, y, z, rd, lh };
          break;
        }

        if (!chosen) {
          failedMap[item.key] = (failedMap[item.key]||0) + 1; countFailed++; continue;
        }

        cursorX = chosen.x; cursorY = chosen.y; cursorZ = chosen.z; rowDepthX = chosen.rd; layerHeightY = chosen.lh;

        const color = item.color || randomColor();
        const pos = [
          container.xOffset + cursorX + chosen.rot.l/2,
          cursorY + chosen.rot.h/2,
          chosen.z + chosen.rot.w/2
        ];

        addBox({ l: chosen.rot.l, h: chosen.rot.h, w: chosen.rot.w }, pos, color, item.key);
        drawn.push({ l: chosen.rot.l, h: chosen.rot.h, w: chosen.rot.w, color, position: pos, key: item.key });
        countPlaced++;

        cursorZ += chosen.rot.w;
        rowDepthX = Math.max(rowDepthX, chosen.rot.l);
        layerHeightY = Math.max(layerHeightY, chosen.rot.h);
      }
    }

    return { drawn, countPlaced, countFailed };
  }

  function getAllRotations(dim) {
    const L = dim.length ?? dim.l, W = dim.width ?? dim.w, H = dim.height ?? dim.h;
    const uniq = new Set();
    const out = [];
    const perms = [
      { l:L, w:W, h:H }, { l:L, w:H, h:W },
      { l:W, w:L, h:H }, { l:W, w:H, h:L },
      { l:H, w:L, h:W }, { l:H, w:W, h:L }
    ];
    for (const p of perms) {
      const k = `${p.l}|${p.w}|${p.h}`;
      if (!uniq.has(k)) { uniq.add(k); out.push(p); }
    }
    out.sort((a,b)=> (a.h-b.h) || ((b.l*b.w)-(a.l*a.w)) );
    return out;
  }

  // ------------------ CONTAINER WIREFRAME FIXED ------------------
  function drawContainerWireframe(type, index) {
    const size = containerSizeMap[type];
    if (!size) throw new Error(`Unknown container type: ${type}`);

    const geometry = new THREE.BoxGeometry(size.length, size.height, size.width);
    const edges = new THREE.EdgesGeometry(geometry);
    const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000 }));

    const xOffset = index === 0 ? 0 : containerOffsets[index-1] + containerSizeMap[data[index-1].type].length + 500;
    containerOffsets[index] = xOffset + size.length;

    line.position.set(xOffset + size.length/2, size.height/2, size.width/2);
    mainGroup.add(line);

    const gridHelper = new THREE.GridHelper(size.length, Math.max(2, Math.round(size.length/500)), 0x999999, 0xdddddd);
    gridHelper.rotation.x = Math.PI/2; 
    gridHelper.position.set(xOffset + size.length/2, 1, size.width/2);
    mainGroup.add(gridHelper);

    return { xOffset, size };
  }

  // ------------------ UI BUILDERS ------------------
  function buildSidebar(payload) {
    let html = '';
    payload.forEach((c, i) => {
      const s = containerSizeMap[c.type];
      html += `
        <div class="containerBox">
          <div class="row"><strong>C${i+1}</strong> <span class="tag">${c.type}</span></div>
          <div class="muted">${s.length}×${s.width}×${s.height} mm</div>
          <div class="muted">Items: ${c.items.reduce((a,b)=>a+(b.qty||1),0)}</div>
        </div>
      `;
    });
    return html;
  }

  function buildReport(stats) {
    let html = '';
    stats.forEach(s => {
      html += `
        <div class="reportBox">
        C${s.containerIndex} [${s.type}]
        Placed: ${s.placed} | Failed: ${s.failed}
${Object.keys(s.failedMap).length ? '\nFailed detail:\n' + Object.entries(s.failedMap).map(([k,v])=>`- ${k}: ${v}`).join('\n') : ''}
        </div>
      `;
    });
    return html;
  }

  // ------------------ MESSAGE & DUMMY ------------------
  window.addEventListener('message', (event) => {
    if (event?.data?.type === 'RENDER_CONTAINER') {
      try { renderFromData(event.data.payload); }
      catch (e) { console.error(e); }
    }
  });

  document.getElementById('btnRenderDummy').addEventListener('click', () => renderDummy());
  document.getElementById('btnClearCache').addEventListener('click', () => { localStorage.clear(); alert('Cache cleared'); });

  function renderDummy() {
    const dummyPayload = [
      {
        type: '40FT (HQ)',
        items: [
          { model: 'FQ803', size: 21, qty: 3, dimensions: { l: 900, w: 600, h: 600 }, color: '#EF4444' },
          { model: 'FQ777', size: 24, qty: 2, dimensions: { l: 1200, w: 500, h: 700 }, color: '#10B981' },
          { model: 'BX22', size: 20, qty: 5, dimensions: { l: 600, w: 400, h: 400 }, color: '#3B82F6' },
          { model: 'Tall', size: 28, qty: 2, dimensions: { l: 500, w: 500, h: 1100 }, color: '#F59E0B' }
        ]
      },
      {
        type: '20FT (GP)',
        items: [
          { model: 'Slim', size: 18, qty: 4, dimensions: { l: 800, w: 300, h: 300 }, color: '#8B5CF6' },
          { model: 'Wide', size: 22, qty: 2, dimensions: { l: 1000, w: 800, h: 500 }, color: '#06B6D4' }
        ]
      }
    ];
    renderFromData(dummyPayload);
  }

  window.addEventListener('DOMContentLoaded', () => {
    if (window.top === window.self) renderDummy();
  });

  // ------------------ RESIZE & ANIMATE ------------------
  function onResize() {
    const w = window.innerWidth; const h = window.innerHeight;
    renderer.setSize(w, h);
    camera.aspect = w / h; camera.updateProjectionMatrix();
  }
  window.addEventListener('resize', onResize);

  function animate() {
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
  }
  animate();
  </script>
</body>
</html>
