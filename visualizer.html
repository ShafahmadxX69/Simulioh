<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Container Visualizer – Auto Rotation & Mixed Items (Multi-Container)</title>
  <style>
    :root{
      --panel-bg:#f7f7f8; --border:#d8d8de;
      --mono:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;
    }
    *{box-sizing:border-box}
    body{margin:0;overflow:hidden;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
    canvas{display:block}
    #sidebar{position:absolute;inset:0 auto 0 0;width:280px;background:var(--panel-bg);border-right:1px solid var(--border);z-index:10;padding:12px;overflow:auto}
    #sidebar h3{margin:0 0 8px}
    .containerBox{background:#fff;border:1px solid var(--border);border-radius:10px;padding:10px;margin-bottom:10px}
    .muted{color:#666;font-size:12px}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .tag{border:1px solid var(--border);border-radius:999px;padding:2px 8px;font-size:12px;background:#fff}
    #reportContainer{position:absolute;left:280px;right:0;bottom:0;background:rgba(255,255,255,0.96);border-top:2px solid #000;z-index:5;font-family:var(--mono);font-size:12px;max-height:35%;overflow:auto;display:flex;flex-wrap:wrap;gap:8px;padding:8px}
    .reportBox{border:1px solid var(--border);background:#fff;border-radius:8px;padding:10px;white-space:pre-wrap;flex:1 1 320px}
    #topbar{position:absolute;left:280px;right:0;top:0;height:46px;background:rgba(255,255,255,0.9);border-bottom:1px solid var(--border);display:flex;align-items:center;gap:8px;padding:0 10px;z-index:8;backdrop-filter:blur(4px)}
    #topbar button,#topbar select{border:1px solid var(--border);background:#fff;padding:6px 10px;border-radius:8px;cursor:pointer;font-size:13px}
    #topbar .spacer{flex:1}
    #legend{font-family:var(--mono);font-size:11px;color:#444}
  </style>
</head>
<body>
  <div id="sidebar">
    <h3>Container List</h3>
    <div id="containerList"></div>
    <div id="legend" class="muted">
      <p><strong>Legend:</strong></p>
      <p>- X: depan → belakang (panjang)<br>
         - Y: lantai → atas (tinggi)<br>
         - Z: kiri → kanan (lebar)</p>
      <p>- GAP logika: 0 mm (kapasitas penuh)<br>- Visual shrink: 0.5 mm (anti nembus)</p>
    </div>
  </div>

  <div id="topbar">
    <button id="btnRenderDummy" title="Render contoh payload">Render Dummy</button>
    <button id="btnClearCache" title="Hapus cache lokal">Clear Cache</button>
    <label class="muted">Mode: Auto (rotasi & mix multi-item, multi-container)</label>
    <div class="spacer"></div>
    <span class="muted">Tip: kirim payload via <code>postMessage</code> → { type:"RENDER_CONTAINER", payload }</span>
  </div>

  <div id="reportContainer"></div>
  <canvas id="threeCanvas"></canvas>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script>
  // ------------------ CONFIG ------------------
  // Kapasitas pakai ukuran yang kamu gunakan (kompatibel dengan Index yang map-nya "20FT (GP)" dst).
  const LOGIC_GAP = 0;             // Tidak ada gap pada perhitungan kapasitas
  const VISUAL_SHRINK = 0.5;       // Epsilon untuk cegah z-fighting
  const CONTAINER_SPACING = 500;   // Jarak antar kontainer saat dirender berdampingan
  const ENABLE_CACHE = true;

  const containerSizeMap = {
    "20FT (GP)": { length: 5898, width: 2352, height: 2393 },
    "40FT (GP)": { length: 12032, width: 2352, height: 2393 },
    "40FT (HQ)": { length: 12032, width: 2352, height: 2698 }
  };

  // ------------------ THREE SETUP ------------------
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0xffffff);
  const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 100000);
  camera.position.set(9000, 6000, 9000);

  const renderer = new THREE.WebGLRenderer({ canvas: document.querySelector('#threeCanvas'), antialias: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);

  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true; controls.dampingFactor = 0.08;

  const ambient = new THREE.AmbientLight(0xffffff, 0.9); scene.add(ambient);
  const dir = new THREE.DirectionalLight(0xffffff, 0.6); dir.position.set(1,2,1); scene.add(dir);

  const mainGroup = new THREE.Group(); scene.add(mainGroup);
  let containerOffsets = [], data = [];

  // ------------------ UTIL ------------------
  function hashPayload(payload){
    try{ return btoa(unescape(encodeURIComponent(JSON.stringify(payload)))).slice(0,160); }
    catch{ return String(Date.now()); }
  }
  function clearScene(){ mainGroup.clear(); }

  function withOutline(mesh, color = 0x000000){
    const edges = new THREE.EdgesGeometry(mesh.geometry);
    const line  = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color }));
    mesh.add(line); return mesh;
  }

  function makeBoxMaterial(color){
    return new THREE.MeshStandardMaterial({
      color: new THREE.Color(color),
      transparent: false,
      opacity: 0.98,
      polygonOffset: true,
      polygonOffsetFactor: 1,
      polygonOffsetUnits: 1
    });
  }

  function addBox(dim, pos, color, xOffset){
    // Sedikit dikurangi untuk mencegah nembus dinding
    const l = Math.max(1, dim.l - VISUAL_SHRINK);
    const h = Math.max(1, dim.h - VISUAL_SHRINK);
    const w = Math.max(1, dim.w - VISUAL_SHRINK);

    const geometry = new THREE.BoxGeometry(l, h, w);
    const material = makeBoxMaterial(color || '#888');
    const box = new THREE.Mesh(geometry, material);

    // pos = {x,y,z} dari sudut kiri-depan-bawah kontainer
    box.position.set(pos.x + dim.l/2 + xOffset, pos.y + dim.h/2, pos.z + dim.w/2);
    withOutline(box, 0x111111);
    mainGroup.add(box);
  }

  function getAllRotations(dim){
    const L = dim.length ?? dim.l, W = dim.width ?? dim.w, H = dim.height ?? dim.h;
    const perms = [
      {l:L,w:W,h:H},{l:L,w:H,h:W},
      {l:W,w:L,h:H},{l:W,w:H,h:L},
      {l:H,w:L,h:W},{l:H,w:W,h:L}
    ];
    const uniq = new Set(); const out=[];
    for(const p of perms){ const k=`${p.l}|${p.w}|${p.h}`; if(!uniq.has(k)){ uniq.add(k); out.push(p); } }
    // preferensi: tinggi kecil dulu, lalu alas besar
    out.sort((a,b)=> (a.h-b.h) || ((b.l*b.w)-(a.l*a.w)) );
    return out;
  }

  function vol(d){ return (d.l||d.length)*(d.w||d.width)*(d.h||d.height); }

  // ------------------ CONTAINER WIREFRAME ------------------
  function drawContainerWireframe(type, index){
    const size = containerSizeMap[type];
    if(!size) throw new Error(`Unknown container type: ${type}`);

    const geometry = new THREE.BoxGeometry(size.length, size.height, size.width);
    const edges    = new THREE.EdgesGeometry(geometry);
    const line     = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000 }));

    const xOffset = index===0 ? 0 : containerOffsets[index-1] + containerSizeMap[data[index-1].type].length + CONTAINER_SPACING;
    containerOffsets[index] = xOffset + size.length;

    line.position.set(xOffset + size.length/2, size.height/2, size.width/2);
    mainGroup.add(line);

    const gridHelper = new THREE.GridHelper(size.length, Math.max(2, Math.round(size.length/500)), 0x999999, 0xdddddd);
    gridHelper.rotation.x = Math.PI/2;
    gridHelper.position.set(xOffset + size.length/2, 1, size.width/2);
    mainGroup.add(gridHelper);

    return { xOffset, size };
  }

  // ------------------ PACKING: Guillotine + Grid (multi-item) ------------------
  // Mengisi ruang kosong secara bertahap:
  // 1) Pilih space paling “bawah-depan-kiri” (prioritas Y, lalu X, lalu Z) agar rapi.
  // 2) Untuk space itu, cari item+rotasi yang paling efektif (maks blok terpasang).
  // 3) Tempatkan dalam grid (nx,ny,nz) sebanyak mungkin sesuai qty.
  // 4) Pecah space jadi right/front/top (guillotine) supaya item lain lanjut dari sisa titik itu.
  function packOneContainer(containerObj, index, reportLines){
    const { xOffset, size } = drawContainerWireframe(containerObj.type, index);

    // Normalisasi & urutkan item by volume desc (supaya besar dipertimbangkan dulu)
    const items = containerObj.items.map((it, idx)=>({
      ...it,
      qty: +it.qty || 0,
      key: `${it.model || 'Item'} ${it.size ?? ''}" (C${index+1}-L${idx+1})`,
      dim: { l:(it.dimensions.l ?? it.dimensions.length), w:(it.dimensions.w ?? it.dimensions.width), h:(it.dimensions.h ?? it.dimensions.height) }
    })).filter(i=>i.qty>0);

    // Kalau tidak ada item, tetap catat report
    if(!items.length){
      reportLines.push(`C${index+1} [${containerObj.type}] — Placed: 0 | Failed: 0`);
      return {placed:0, failed:0, failedMap:{}};
    }

    items.sort((a,b)=> vol(b.dim) - vol(a.dim));

    // Ruang awal = seluruh isi kontainer
    let spaces = [{ x:0, y:0, z:0, l:size.length, h:size.height, w:size.width }];

    // Prioritas space: paling bawah, lalu paling depan (X kecil), lalu paling kiri (Z kecil)
    const spaceSort = (a,b)=> (a.y-b.y) || (a.x-b.x) || (a.z-b.z);

    // Hitung kapasitas blok dalam 1 space untuk rotasi r
    function blockCapacityInSpace(s, r){
      const nx = Math.floor((s.l + LOGIC_GAP) / (r.l + LOGIC_GAP));
      const ny = Math.floor((s.h + LOGIC_GAP) / (r.h + LOGIC_GAP));
      const nz = Math.floor((s.w + LOGIC_GAP) / (r.w + LOGIC_GAP));
      return { nx, ny, nz, count: Math.max(0, nx*ny*nz) };
    }

    // Heuristik pemilihan (item, rotasi, space): memaksimalkan jumlah yang bisa ditempatkan pada space itu.
    function chooseBest(space){
      let best = null;
      for(let i=0;i<items.length;i++){
        const it = items[i]; if(it.qty<=0) continue;
        const rots = getAllRotations(it.dim);

        for(const r of rots){
          if(r.l<=0||r.w<=0||r.h<=0) continue;
          if(r.l > space.l || r.w > space.w || r.h > space.h) continue;

          const cap = blockCapacityInSpace(space, r);
          if(cap.count<=0) continue;

          // Skor: utamakan count tinggi, lalu “kepadatan volume” yang digunakan
          const usedVol = (cap.count * r.l * r.w * r.h);
          const spaceVol = space.l * space.w * space.h;
          const density = usedVol / spaceVol;

          const score = cap.count * 1e6 + density; // bobot besar untuk count
          if(!best || score > best.score){
            best = { itemIndex:i, rot:r, cap, score };
          }
        }
      }
      return best;
    }

    let totalPlaced = 0;
    const failedMap = {};

    // Loop sampai tidak ada space yang bisa diisi atau semua qty habis
    while(spaces.length){
      spaces.sort(spaceSort);
      const s = spaces.shift();

      const pick = chooseBest(s);
      if(!pick){
        // Space ini tidak bisa dipakai untuk item manapun → buang
        continue;
      }

      const it = items[pick.itemIndex];
      const { rot, cap } = pick;

      // Banyak yang benar-benar akan ditempatkan = min(qty, kapasitas blok space)
      const toPlace = Math.min(it.qty, cap.count);
      if(toPlace<=0){
        // Tidak jadi menempatkan apa pun, lanjut space berikut
        continue;
      }

      // Tempatkan blok dalam urutan Y->X->Z agar stabil
      let placedHere = 0;
      outer:
      for(let y=0; y<cap.ny; y++){
        for(let x=0; x<cap.nx; x++){
          for(let z=0; z<cap.nz; z++){
            if(placedHere >= toPlace) break outer;

            const pos = {
              x: s.x + x*(rot.l + LOGIC_GAP),
              y: s.y + y*(rot.h + LOGIC_GAP),
              z: s.z + z*(rot.w + LOGIC_GAP)
            };

            // Clamp agar tidak keluar kontainer
            if(pos.x + rot.l > size.length || pos.y + rot.h > size.height || pos.z + rot.w > size.width){
              continue;
            }

            addBox(rot, pos, it.color || colorFromKey(it.key), xOffset);
            placedHere++; totalPlaced++;
          }
        }
      }

      // Update qty item
      it.qty -= placedHere;

      // Hitung ruang yang terpakai aktual
      const usedL = Math.min(cap.nx * rot.l, s.l);
      const usedH = Math.min(cap.ny * rot.h, s.h);
      const usedW = Math.min(cap.nz * rot.w, s.w);

      // Pecah sisa ruang: kanan, depan, atas
      const right = { x:s.x + usedL, y:s.y, z:s.z, l: s.l - usedL, h: usedH, w: usedW };
      const front = { x:s.x, y:s.y, z:s.z + usedW, l: usedL, h: usedH, w: s.w - usedW };
      const top   = { x:s.x, y:s.y + usedH, z:s.z, l: s.l, h: s.h - usedH, w: s.w };

      for(const sp of [right, front, top]){
        if(sp.l>0 && sp.h>0 && sp.w>0) spaces.push(sp);
      }

      // Jika item ini masih sisa, akan dipertimbangkan lagi pada space berikutnya.
      // Jika qty item habis, lanjut item lain di iterasi berikutnya.
      const remainingAll = items.reduce((acc, t)=> acc + t.qty, 0);
      if(remainingAll <= 0) break;
    }

    // Hitung gagal
    let totalFailed = 0;
    for(const it of items){
      if(it.qty>0){
        failedMap[it.key] = (failedMap[it.key]||0) + it.qty;
        totalFailed += it.qty;
      }
    }

    // Report per item (opsional, ringkas)
    const lines = [`C${index+1} [${containerObj.type}] — Placed: ${totalPlaced} | Failed: ${totalFailed}`];
    if(Object.keys(failedMap).length){
      for(const [k,v] of Object.entries(failedMap)){ lines.push(`- ${k}: ${v}`); }
    }
    reportLines.push(lines.join('\n'));

    return { placed: totalPlaced, failed: totalFailed, failedMap };
  }

  function colorFromKey(key){
    let h=0; for(let i=0;i<key.length;i++) h=(h*31 + key.charCodeAt(i))>>>0;
    const r=(h&255), g=((h>>8)&255), b=((h>>16)&255);
    return `#${r.toString(16).padStart(2,'0')}${g.toString(16).padStart(2,'0')}${b.toString(16).padStart(2,'0')}`;
  }

  // ------------------ UI BUILDERS ------------------
  function buildSidebar(payload){
    let html='';
    payload.forEach((c,i)=>{
      const s = containerSizeMap[c.type];
      html += `
        <div class="containerBox">
          <div class="row"><strong>C${i+1}</strong> <span class="tag">${c.type}</span></div>
          <div class="muted">${s.length}×${s.width}×${s.height} mm</div>
          <div class="muted">Items: ${c.items.reduce((a,b)=>a+(+b.qty||0),0)}</div>
        </div>
      `;
    });
    return html;
  }

  function buildReport(stats){
    // stats: array {containerIndex,type,placed,failed,failedMap}
    let html='';
    stats.forEach(s=>{
      html += `
        <div class="reportBox">
C${s.containerIndex} [${s.type}]
Placed: ${s.placed} | Failed: ${s.failed}
${Object.keys(s.failedMap).length ? '\nFailed detail:\n' + Object.entries(s.failedMap).map(([k,v])=>`- ${k}: ${v}`).join('\n') : ''}
        </div>
      `;
    });
    return html;
  }

  // ------------------ CORE RENDER ------------------
  function drawFromCache(boxes, containers, stats, payload){
    clearScene(); containerOffsets = [];
    containers.forEach((c,i)=> drawContainerWireframe(c.type, i));
    // Render box yang sudah disimpan
    for(const d of boxes){
      addBox({l:d.l, h:d.h, w:d.w}, {x:d.x, y:d.y, z:d.z}, d.color, d.xOffset);
    }
    document.getElementById('containerList').innerHTML = buildSidebar(payload);
    document.getElementById('reportContainer').innerHTML = buildReport(stats);
  }

  function renderFromData(payload, {useCache=ENABLE_CACHE}={}){
    const reportEl = document.getElementById('reportContainer');
    const listEl   = document.getElementById('containerList');

    const hash = hashPayload(payload);
    const cacheKey = `cachedBoxes_${hash}`;
    if(useCache){
      const cached = localStorage.getItem(cacheKey);
      if(cached){
        const parsed = JSON.parse(cached);
        drawFromCache(parsed.boxes, parsed.containers, parsed.stats, payload);
        return;
      }
    }

    clearScene(); reportEl.innerHTML=''; listEl.innerHTML='';
    data = payload; containerOffsets = [];

    const allBoxesForCache = [];  // simpan posisi absolut untuk cache (per box)
    const globalStats = [];
    const perContainerReport = [];

    // Hook addBox untuk penulisan cache
    const _addBox = addBox;
    addBox = function(dim, pos, color, xOffset){
      _addBox(dim, pos, color, xOffset);
      allBoxesForCache.push({ l:dim.l, h:dim.h, w:dim.w, x:pos.x, y:pos.y, z:pos.z, color, xOffset });
    };

    payload.forEach((containerObj, cIndex) => {
      const result = packOneContainer(containerObj, cIndex, perContainerReport);
      globalStats.push({
        containerIndex: cIndex+1,
        type: containerObj.type,
        placed: result.placed,
        failed: result.failed,
        failedMap: result.failedMap
      });
    });

    // Kembalikan addBox asli agar tidak double-log bila dipakai lagi
    addBox = _addBox;

    localStorage.setItem(cacheKey, JSON.stringify({
      boxes: allBoxesForCache,
      containers: payload.map(p=>({type:p.type})),
      stats: globalStats
    }));

    listEl.innerHTML = buildSidebar(payload);
    reportEl.innerHTML = buildReport(globalStats);
  }

  // ------------------ MESSAGE & DUMMY ------------------
  window.addEventListener('message', (event)=>{
    if(event?.data?.type === 'RENDER_CONTAINER'){
      try{ renderFromData(event.data.payload, {useCache:false}); }
      catch(e){ console.error(e); }
    }
  });

  document.getElementById('btnRenderDummy').addEventListener('click', ()=> renderDummy());
  document.getElementById('btnClearCache').addEventListener('click', ()=>{ localStorage.clear(); alert('Cache cleared'); });

  function renderDummy(){
    // Contoh: multi-container + multi-item berbeda dimensi
    const dummyPayload = [
      {
        type: '40FT (HQ)',
        items: [
          { model: 'FQ803', size: 24, qty: 220, dimensions: { l: 600, w: 400, h: 300 }, color: '#F472B6' },
          { model: 'Addon', size: 22, qty: 120, dimensions: { l: 500, w: 500, h: 300 }, color: '#60A5FA' },
          { model: 'Tall',  size: 30, qty:  60, dimensions: { l: 400, w: 400, h: 500 }, color: '#34D399' }
        ]
      },
      {
        type: '20FT (GP)',
        items: [
          { model: 'Small', size: 16, qty: 300, dimensions: { l: 300, w: 250, h: 200 }, color: '#F59E0B' },
          { model: 'Mix2',  size: 21, qty: 120, dimensions: { l: 420, w: 260, h: 260 }, color: '#A78BFA' }
        ]
      }
    ];
    renderFromData(dummyPayload, { useCache:false });
  }

  window.addEventListener('DOMContentLoaded', ()=>{
    // Auto demo kalau dibuka langsung (bukan di dalam iframe Index)
    if(window.top === window.self) renderDummy();
  });

  // ------------------ RESIZE & ANIMATE ------------------
  function onResize(){
    const w = window.innerWidth, h = window.innerHeight;
    renderer.setSize(w,h); camera.aspect = w/h; camera.updateProjectionMatrix();
  }
  window.addEventListener('resize', onResize);

  function animate(){ requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }
  animate();
  </script>
</body>
</html>
