<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Container Visualizer â€“ No Gap</title>
  <style>
    body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
    canvas { display: block; }
    #report {
      position: absolute;
      left: 0; right: 0; bottom: 0;
      background: #ffffffcc;
      max-height: 35%;
      overflow: auto;
      font-size: 12px;
      font-family: monospace;
      padding: 6px;
      white-space: pre-wrap;
    }
    #topbar {
      position: absolute;
      top: 0; left: 0; right: 0;
      height: 40px;
      background: #fff;
      display: flex;
      align-items: center;
      padding: 0 8px;
      gap: 8px;
      border-bottom: 1px solid #ccc;
      z-index: 10;
    }
  </style>
</head>
<body>
  <div id="topbar">
    <button id="btnClearCache">Clear Cache</button>
    <span>Mode: No Gap (Box pas dengan container)</span>
  </div>
  <div id="report"></div>
  <canvas id="threeCanvas"></canvas>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script>
  // Container Dimensions
  const containerSizeMap = {
    "20FT (GP)": { length: 5898, width: 2352, height: 2393 },
    "40FT (GP)": { length: 12032, width: 2352, height: 2393 },
    "40FT (HQ)": { length: 12032, width: 2352, height: 2698 }
  };

  // THREE.js setup
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0xffffff);
  const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 100000);
  camera.position.set(9000, 6000, 9000);

  const renderer = new THREE.WebGLRenderer({ canvas: document.querySelector('#threeCanvas'), antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;

  const amb = new THREE.AmbientLight(0xffffff, 0.9);
  scene.add(amb);
  const dir = new THREE.DirectionalLight(0xffffff, 0.6);
  dir.position.set(1, 2, 1);
  scene.add(dir);

  const mainGroup = new THREE.Group();
  scene.add(mainGroup);

  function withOutline(mesh) {
    const edges = new THREE.EdgesGeometry(mesh.geometry);
    mesh.add(new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000 })));
    return mesh;
  }

  function addBox(dim, pos, color, containerSize) {
    // clamp agar tidak melebihi kontainer
    if (pos.x + dim.w > containerSize.width ||
        pos.y + dim.h > containerSize.height ||
        pos.z + dim.l > containerSize.length) {
      return; // skip box ini
    }

    // Box sesuai ukuran asli (tanpa gap)
    const geo = new THREE.BoxGeometry(dim.w, dim.h, dim.l);
    const mat = new THREE.MeshStandardMaterial({ color: new THREE.Color(color), opacity: 0.97 });
    const box = new THREE.Mesh(geo, mat);
    box.position.set(pos.x + dim.w/2, pos.y + dim.h/2, pos.z + dim.l/2);
    withOutline(box);
    mainGroup.add(box);
  }

  function getAllRotations(d) {
    const L = d.length ?? d.l, W = d.width ?? d.w, H = d.height ?? d.h;
    return [
      { l: L, w: W, h: H },
      { l: L, w: H, h: W },
      { l: W, w: L, h: H },
      { l: W, w: H, h: L },
      { l: H, w: L, h: W },
      { l: H, w: W, h: L }
    ];
  }

  function packContainer(c) {
    const size = containerSizeMap[c.type];

    const wireGeo = new THREE.BoxGeometry(size.width, size.height, size.length);
    const wire = new THREE.LineSegments(new THREE.EdgesGeometry(wireGeo), new THREE.LineBasicMaterial({ color: 0x000000 }));
    wire.position.set(size.width/2, size.height/2, size.length/2);
    mainGroup.add(wire);

    const report = [];
    let currentZ = 0;

    while (currentZ < size.length) {
      let filled = false;
      for (const it of c.items) {
        const rots = getAllRotations({ l: it.dimensions.length, w: it.dimensions.width, h: it.dimensions.height });
        for (const rot of rots) {
          if (rot.l <= size.length && rot.w <= size.width && rot.h <= size.height) {
            const nx = Math.floor(size.width / rot.w);
            const ny = Math.floor(size.height / rot.h);
            const nz = Math.floor((size.length - currentZ) / rot.l);
            const count = nx * ny * nz;
            if (count === 0) continue;

            const toPlace = Math.min(count, it.qty);
            let placedHere = 0;
            for (let y = 0; y < ny; y++) {
              for (let x = 0; x < nx; x++) {
                for (let z = 0; z < nz; z++) {
                  if (placedHere >= toPlace) break;
                  const pos = { x: x * rot.w, y: y * rot.h, z: currentZ + z * rot.l };
                  addBox(rot, pos, it.color || '#888', size);
                  placedHere++;
                  it.qty--;
                  filled = true;
                }
              }
            }
            report.push(`${c.label} - ${it.model} ${it.size}: Placed ${toPlace}`);
          }
        }
      }
      if (!filled) break;
      currentZ += 1000; // maju layer by layer
    }

    return report.join('\n');
  }

  function renderContainers(payload) {
    mainGroup.clear();
    const reports = [];
    payload.forEach((c, i) => {
      c.label = `C${i + 1}`;
      reports.push(packContainer(c));
    });
    document.getElementById('report').textContent = reports.join('\n\n');
  }

  window.addEventListener('message', e => { if (e.data?.type === 'RENDER_CONTAINER') renderContainers(e.data.payload); });

  document.getElementById('btnClearCache').addEventListener('click', () => {
    localStorage.clear();
    alert('Cache cleared');
  });

  window.addEventListener('resize', () => {
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
  });

  (function anim() {
    requestAnimationFrame(anim);
    controls.update();
    renderer.render(scene, camera);
  })();
  </script>
</body>
</html>
