<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D Container Visualizer</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      overflow: hidden;
      font-family: sans-serif;
    }
    #reportContainer {
      position: absolute;
      top: 10px;
      left: 10px;
      max-width: 320px;
      max-height: 95%;
      overflow: auto;
      padding: 8px;
      background: rgba(255,255,255,0.9);
      font-size: 13px;
      line-height: 1.4em;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    .reportBox {
      white-space: pre-line;
      font-family: monospace;
    }
    #btnClearCache {
      position: absolute;
      top: 10px;
      right: 10px;
      padding: 6px 10px;
      font-size: 12px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div id="reportContainer"></div>
  <button id="btnClearCache">Clear Cache</button>
  <script src="https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.161.0/examples/js/controls/OrbitControls.js"></script>
  <script>
    let scene = new THREE.Scene();
    scene.background = new THREE.Color(0xffffff);
    let camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 1, 100000);
    camera.position.set(5000, 3000, 5000);

    let renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    let controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    let ambient = new THREE.AmbientLight(0xffffff, 0.9);
    scene.add(ambient);
    let dir = new THREE.DirectionalLight(0xffffff, 0.5);
    dir.position.set(1,1,1);
    scene.add(dir);

    const containerSizeMap = {
      '20FT': { length: 5898, width: 2352, height: 2393 },
      '40FT': { length: 12032, width: 2352, height: 2393 },
      '40HC': { length: 12032, width: 2352, height: 2698 }
    };
    let data = [];
    let containerOffsets = [];

    function clearScene(){
      for(let i=scene.children.length-1;i>=0;i--){
        let obj=scene.children[i];
        if(obj.isMesh) scene.remove(obj);
      }
    }
    function addBox(dim,pos,color,xOffset){
      let g = new THREE.BoxGeometry(dim.l, dim.h, dim.w);
      let m = new THREE.MeshBasicMaterial({color:color, transparent:true, opacity:0.8});
      let box = new THREE.Mesh(g,m);
      box.position.set(pos.x+dim.l/2+xOffset, pos.y+dim.h/2, pos.z+dim.w/2);
      scene.add(box);

      let edges = new THREE.EdgesGeometry(g);
      let line = new THREE.LineSegments(edges,new THREE.LineBasicMaterial({color:0x000000}));
      line.position.copy(box.position);
      scene.add(line);
    }
    function drawContainerWire(size, xOffset){
      let geo = new THREE.BoxGeometry(size.length, size.height, size.width);
      let mat = new THREE.MeshBasicMaterial({color:0x000000, wireframe:true, transparent:true, opacity:0.2});
      let mesh = new THREE.Mesh(geo,mat);
      mesh.position.set(size.length/2+xOffset, size.height/2, size.width/2);
      scene.add(mesh);
    }
    function getAllRotations(dim){
      const {l,w,h}=dim;
      return [
        {l,h,w}, {l,w,h},
        {h,l,w}, {h,w,l},
        {w,l,h}, {w,h,l}
      ];
    }

    function packContainer(container){
      const size = containerSizeMap[container.type];
      const xOffset = container.index===0 ? 0 :
        containerOffsets[container.index-1] + containerSizeMap[data[container.index-1].type].length + 500;
      containerOffsets[container.index] = xOffset + size.length;

      drawContainerWire(size,xOffset);

      let items = container.items
        .map(it => ({
          ...it,
          qty: parseInt(it.qty)||0,
          dims: {
            l: it.dimensions.length,
            w: it.dimensions.width,
            h: it.dimensions.height
          }
        }))
        .filter(it=>it.qty>0)
        .sort((a,b)=> (b.dims.l*b.dims.w*b.dims.h)-(a.dims.l*a.dims.w*a.dims.h));

      let cursorX=0,cursorY=0,cursorZ=0;
      let rowDepth=0;
      const report=[];

      for(const it of items){
        let placed=0;
        let rots=getAllRotations(it.dims);

        while(it.qty>0){
          let fit=null;
          for(const r of rots){
            if(cursorX+r.l <= size.length &&
               cursorY+r.h <= size.height &&
               cursorZ+r.w <= size.width){
              fit=r; break;
            }
          }
          if(!fit){
            cursorZ=0;
            cursorY=0;
            cursorX += (rowDepth>0 ? rowDepth : 200);
            rowDepth=0;
            if(cursorX>=size.length) break;
            continue;
          }

          addBox(fit,{x:cursorX,y:cursorY,z:cursorZ}, it.color||'#888', xOffset);
          placed++; it.qty--;

          cursorZ += fit.w;
          rowDepth = Math.max(rowDepth, fit.l);

          if(cursorZ+fit.w > size.width){
            cursorZ=0;
            cursorY += fit.h;
          }
        }
        report.push(`${container.label} — ${it.model} ${it.size} → Placed: ${placed}`);
        if(it.qty>0){
          report.push(`⚠️ Sisa ${it.qty} ${it.model} tidak muat`);
          console.warn("Not all items placed:", it);
        }
      }
      return report.join('\n');
    }

    function renderContainers(payload){
      clearScene(); containerOffsets=[];
      data = payload.map((c,i)=>({...c,index:i,label:`C${i+1}`}));
      const reports=[];
      for(const c of data){
        reports.push(packContainer(c));
      }
      showReport(reports.join('\n\n'));
    }
    function showReport(text){
      const el=document.getElementById('reportContainer');
      el.innerHTML='';
      const box=document.createElement('div');
      box.className='reportBox';
      box.textContent=text||'—';
      el.appendChild(box);
    }

    window.addEventListener('message', (event)=>{
      if(event?.data?.type==='RENDER_CONTAINER'){
        try{ renderContainers(event.data.payload); }
        catch(e){ console.error(e); showReport('Error: '+e.message); }
      }
    });

    document.getElementById('btnClearCache').addEventListener('click',()=>{
      localStorage.clear();
      alert('Cache cleared');
    });

    function onResize(){
      let w=window.innerWidth,h=window.innerHeight;
      renderer.setSize(w,h);
      camera.aspect=w/h;
      camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', onResize);

    function animate(){
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene,camera);
    }
    animate();
  </script>
</body>
</html>
