<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Container Visualizer</title>
  <style>
    body { margin: 0; overflow: hidden; }
    #threeCanvas { width: 100vw; height: 100vh; display: block; }
    #reportContainer {
      position: absolute; top: 10px; left: 10px;
      background: rgba(255,255,255,0.9);
      padding: 10px; border-radius: 6px;
      font-family: Arial, sans-serif; font-size: 12px;
      max-height: 90vh; overflow-y: auto;
    }
  </style>
</head>
<body>
  <canvas id="threeCanvas"></canvas>
  <div id="reportContainer"></div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script>
  // ------------------ CONFIG ------------------
  const GAP = 0;       // fisik: box nempel dinding/lantai/plafon
  const VIS_GAP = 2;   // visualisasi: supaya kotak ada garis pembeda

  const containerSizeMap = {
    "20FT (GP)": { length: 5898,  width: 2352, height: 2393 },
    "40FT (GP)": { length: 12032, width: 2352, height: 2393 },
    "40FT (HQ)": { length: 12032, width: 2352, height: 2698 }
  };

  // ------------------ THREE SETUP ------------------
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0xffffff);
  const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 100000);
  camera.position.set(9000, 6000, 9000);

  const renderer = new THREE.WebGLRenderer({ canvas: document.querySelector('#threeCanvas'), antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);

  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.target.set(6000,1500,1200);

  const ambient = new THREE.AmbientLight(0xffffff, 0.9);
  scene.add(ambient);
  const light = new THREE.DirectionalLight(0xffffff, 0.5);
  light.position.set(5000, 10000, 7500);
  scene.add(light);

  const mainGroup = new THREE.Group();
  scene.add(mainGroup);

  // ------------------ HELPERS ------------------
  function withOutline(mesh, color=0x000000){
    const geo = new THREE.EdgesGeometry(mesh.geometry);
    const mat = new THREE.LineBasicMaterial({ color: color, linewidth: 1 });
    const wireframe = new THREE.LineSegments(geo, mat);
    mesh.add(wireframe);
  }

  function addBox(dim, pos, color, key){
    const geometry = new THREE.BoxGeometry(
      Math.max(1, dim.l - VIS_GAP),
      Math.max(1, dim.h - VIS_GAP),
      Math.max(1, dim.w - VIS_GAP)
    );
    const material = new THREE.MeshStandardMaterial({
      color: new THREE.Color(color), transparent:false, opacity:0.95
    });
    const box = new THREE.Mesh(geometry, material);
    box.position.set(pos[0], pos[1], pos[2]);
    box.userData.key = key;
    withOutline(box, 0x000000);
    mainGroup.add(box);
  }

  function drawContainerWireframe(container, index){
    const { length, width, height } = containerSizeMap[container.type];
    const geo = new THREE.BoxGeometry(length, height, width);
    const mat = new THREE.MeshBasicMaterial({ color:0x000000, wireframe:true, opacity:0.2, transparent:true });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(container.xOffset + length/2, height/2, width/2);
    mainGroup.add(mesh);
    return { size:{length, width, height}, xOffset:container.xOffset };
  }

  function getAllRotations(dim){
    return [
      { l:dim.l, w:dim.w, h:dim.h },
      { l:dim.l, w:dim.h, h:dim.w },
      { l:dim.w, w:dim.l, h:dim.h },
      { l:dim.w, w:dim.h, h:dim.l },
      { l:dim.h, w:dim.l, h:dim.w },
      { l:dim.h, w:dim.w, h:dim.l }
    ];
  }

  // ------------------ AUTO PACK ------------------
  function autoPack(container, items){
    const size = container.size;
    let y = 0;
    for(const it of items){
      while(it.qty > 0 && y + it.dimensions.h <= size.height){
        const rot = getAllRotations(it.dimensions).find(r=> r.h + GAP <= size.height - y);
        if(!rot) break;
        let z = 0;
        while(z + rot.w <= size.width && it.qty > 0){
          let x = 0;
          while(x + rot.l <= size.length && it.qty > 0){
            const pos = [
              container.xOffset + (rot.l/2) + x,
              y + (rot.h/2),
              z + (rot.w/2)
            ];
            addBox(rot, pos, it.color, it.model);
            it.qty--;
            x += rot.l;
          }
          z += rot.w;
        }
        y += rot.h;
      }
    }
  }

  // ------------------ MAIN RENDER ------------------
  function renderFromData(payload){
    mainGroup.clear();
    payload.forEach((cont, idx)=>{
      const container = drawContainerWireframe(cont, idx);
      autoPack(container, cont.items);
    });
  }

  // ------------------ WAIT FOR INDEX.HTML ------------------
  window.addEventListener("message", (event)=>{
    if(event.data && event.data.type === "renderBoxes"){
      renderFromData(event.data.payload);
    }
  });

  function animate(){
    requestAnimationFrame(animate);
    controls.update();
    renderer.render(scene, camera);
  }
  animate();

  </script>
</body>
</html>
